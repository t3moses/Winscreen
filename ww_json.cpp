
/*
 * 
 * Use this service https://arduinojson.org/v6/assistant/#/step1 to create the code.
 * Don't forget to delete  and .
 * 
 */
 
#include "ww_constants.h"
#include "ww_types.h"
#include "ww_page.h"
#include "ww_filter.h"
#include "ww_vector.h"
#include "ww_client.h"
#include <ArduinoJson.h>
#include "ww_json.h"

ww_json::ww_json() {}

void ww_json::v_begin( var_display_data_t* p_var_display_data,
                       correction_data_t* p_correction_data ) {

  ww_json::p_var_display_data = p_var_display_data;
  ww_json::p_correction_data = p_correction_data;

}


void ww_json::v_json_null( char* pac_json_null ) {

//
// Return a null value when there is no json to fit the situation.
//

  JsonDocument null;

  null["-"] = "-";

  serializeJson( null, pac_json_null, 128 );

  delay( 100 );

}



void ww_json::v_json_req_this( char* pac_json_req_this ) {

  JsonDocument req_this;

  req_this["key"] = "req";
  req_this["value"] = "this";

  serializeJson( req_this, pac_json_req_this, 128 );

  delay( 100 );

}



void ww_json::v_json_resp_next( int8_t s8_client, char* pac_json_resp_next ) {

String s_next = ww_client::s_next_from_client( s8_client );

  JsonDocument next_client;

  next_client["key"] = "next";
  next_client["value"] = s_next;

  serializeJson(next_client, pac_json_resp_next, 128);

  delay( 100 );

}



void ww_json::v_json_const_01( char* pac_json_const_01 ) {

//
// Load the JSON constants for page 01 into an array.
//

  JsonDocument const_01;

  const_01["key"] = "constants";

  JsonObject display = const_01["display"].to<JsonObject>();
  display["bkgnd"] = BACKGROUND;
  display["pw"] = PANEL_WIDTH;
  display["vph"] = VECTOR_PANEL_HEIGHT;
  display["bph"] = BALL_PANEL_HEIGHT;
  display["hcr"] = HULL_COLOUR;

  JsonObject rdr = const_01["rdr"].to<JsonObject>();
  rdr["clr"] = RUDDER_COLOUR;
  rdr["wt"] = RUDDER_WEIGHT;

  JsonObject bt = const_01["bt"].to<JsonObject>();
  bt["clr"] = BOAT_COLOUR;
  bt["s_clr"] = BOAT_SHADOW_COLOUR;
  bt["wt"] = BOAT_WEIGHT;
  bt["s_wt"] = BOAT_SHADOW_WEIGHT;

  JsonObject tw = const_01["tw"].to<JsonObject>();
  tw["clr"] = TW_COLOUR;
  tw["s_clr"] = TW_SHADOW_COLOUR;
  tw["wt"] = TW_WEIGHT;
  tw["s_wt"] = TW_SHADOW_WEIGHT;

  JsonObject aw = const_01["aw"].to<JsonObject>();
  aw["clr"] = AW_COLOUR;
  aw["wt"] = AW_WEIGHT;

  JsonObject vmg = const_01["vmg"].to<JsonObject>();
  vmg["wt"] = VMG_WEIGHT;
  vmg["s_wt"] = VMG_SHADOW_WEIGHT;
  const_01["n"]["clr"] = TRUE_NORTH_COLOUR;

  JsonObject m = const_01["m"].to<JsonObject>();
  m["clr"] = MAGNETIC_NORTH_COLOUR;
  m["wt"] = MAGNETIC_NORTH_WEIGHT;
  const_01["crh_b"]["clr"] = CRH_BALL_COLOUR;
  const_01["trn_b"]["clr"] = TRN_BALL_COLOUR;

  JsonObject hbt = const_01["hbt"].to<JsonObject>();
  hbt["x"] = HEART_BEAT_X;
  hbt["y"] = HEART_BEAT_Y;
  hbt["s"] = HEART_BEAT_SIDE;

  serializeJson(const_01, pac_json_const_01, 2048);
  delay(100);

}



void ww_json::v_json_const_02( char* pac_json_const_02 ) {

//
// Load the constant display data for page 02 into a JSON array.
// The remaining code was generated by ArduinoJson.
//
// char* output;
// size_t outputCapacity;

  JsonDocument const_02;

  const_02["key"] = "constants";

  JsonObject display = const_02["display"].to<JsonObject>();
  display["bkgnd"] = P2_BACKGROUND;
  display["txt_clr"] = P2_TEXT_COLOUR;
  display["pw"] = P2_PANEL_WIDTH;
  display["ph"] = P2_PANEL_HEIGHT;
  display["y1"] = P2_ROW_TOP_1;
  display["y2"] = P2_ROW_TOP_2;
  display["y3"] = P2_ROW_TOP_3;

  JsonObject txt = const_02["txt"].to<JsonObject>();
  txt["t01"] = "VMG";
  txt["t02"] = "KNOTS";

  serializeJson(const_02, pac_json_const_02, 512);

  delay(100);

}



void ww_json::v_json_const_03( char* pac_json_const_03 ) {

//
// Load the constant display data for page 03 into a JSON array.
// The remaining code was generated by ArduinoJson.
//
// char* output;
// size_t outputCapacity;

  JsonDocument const_03;

  const_03["key"] = "constants";

  JsonObject display = const_03["display"].to<JsonObject>();
  display["bkgnd"] = P3_BACKGROUND;
  display["txt_clr"] = P3_TEXT_COLOUR;
  display["aw_clr"] = P3_OFFSET_COLOUR;
  display["var_clr"] = P3_VARIATION_COLOUR;
  display["z_clr"] = P3_ZERO_COLOUR;
  display["rw1"] = P3_ROW_WIDTH_1;
  display["rw2"] = P3_ROW_WIDTH_2;
  display["rw3"] = P3_ROW_WIDTH_3;
  display["rh"] = P3_ROW_HEIGHT;
  display["iw"] = P3_INDICATOR_WIDTH;

  JsonObject txt = const_03["txt"].to<JsonObject>();
  txt["pan_01_01"] = "OFFSET: ";
  txt["pan_01_02"] = " DEG";
  txt["pan_03_01"] = "VARIATION: ";
  txt["pan_03_02"] = " DEG";
  txt["pan_05_01"] = "Fc: ";
  txt["pan_05_02"] = " Hz";

  serializeJson(const_03, pac_json_const_03, 1024);

  delay(100);

}



void ww_json::v_json_const_04( char* pac_json_const_04 ) {

//
// Load the constant display data for page 04 into a JSON array.
// The remaining code was generated by ArduinoJson.
//

  JsonDocument const_04;

  const_04["key"] = "constants";

  JsonObject display = const_04["display"].to<JsonObject>();
  display["bkgnd"] = P4_BACKGROUND;
  display["txt_clr"] = P4_TEXT_COLOUR;
  display["pw"] = P4_PANEL_WIDTH;
  display["ph"] = P4_PANEL_HEIGHT;
  display["y1"] = P4_ROW_TOP_1;
  display["y2"] = P4_ROW_TOP_2;
  display["y3"] = P4_ROW_TOP_3;
  display["y4"] = P4_ROW_TOP_4;
  display["y5"] = P4_ROW_TOP_5;
  display["y6"] = P4_ROW_TOP_6;

  JsonObject txt = const_04["txt"].to<JsonObject>();
  txt["t01"] = "DEVIATION";
  txt["t02"] = "COURSE";
  txt["t03"] = "DEGREES";
  txt["t04"] = "ONLY VALID WHEN MOTORING";

  serializeJson(const_04, pac_json_const_04, 1024);

  delay(100);

}



void ww_json::v_json_var_01( perspective_t e_perspective, char* pac_json_var_01 ) {

//
// Load the variable display data for page 01 into a JSON array.
//
// Choose the angle, heading-relative-to-reference, according to the client's page.

switch( e_perspective ){
  case HEAD_UP:
  d_hrr = 0.0;
  break;
  case NORTH_UP:
  d_hrr = -ww_vector::d_angle_from_radial( p_var_display_data->xd_nh );
  break;
  case WIND_UP:
  d_hrr = -ww_vector::d_angle_from_radial( p_var_display_data->xd_th );
  break;
  default:
  d_hrr = 0.0;
  break;
}

// Calculate string representations of the component vectors of the points of the true and magnetic north arrows in pixels.

  arrowhead_t xa_nh = x_arrow_head_from_radial( p_var_display_data->xd_nh );
  arrowhead_t xa_mh = x_arrow_head_from_radial( p_var_display_data->xd_mh );

  s_nr_0_x = (String)(int16_t)( PIXELS_PER_FOOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( xa_nh.x_p0, d_hrr )).x );
  s_nr_0_y = (String)(int16_t)( -PIXELS_PER_FOOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( xa_nh.x_p0, d_hrr )).y );
  s_nr_1_x = (String)(int16_t)( PIXELS_PER_FOOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( xa_nh.x_p1, d_hrr )).x );
  s_nr_1_y = (String)(int16_t)( -PIXELS_PER_FOOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( xa_nh.x_p1, d_hrr )).y );
  s_nr_2_x = (String)(int16_t)( PIXELS_PER_FOOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( xa_nh.x_p2, d_hrr )).x );
  s_nr_2_y = (String)(int16_t)( -PIXELS_PER_FOOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( xa_nh.x_p2, d_hrr )).y );

  s_mr_0_x = (String)(int16_t)( PIXELS_PER_FOOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( xa_mh.x_p0, d_hrr )).x );
  s_mr_0_y = (String)(int16_t)( -PIXELS_PER_FOOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( xa_mh.x_p0, d_hrr )).y );
  s_mr_1_x = (String)(int16_t)( PIXELS_PER_FOOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( xa_mh.x_p1, d_hrr )).x );
  s_mr_1_y = (String)(int16_t)( -PIXELS_PER_FOOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( xa_mh.x_p1, d_hrr )).y );
  s_mr_2_x = (String)(int16_t)( PIXELS_PER_FOOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( xa_mh.x_p2, d_hrr )).x );
  s_mr_2_y = (String)(int16_t)( -PIXELS_PER_FOOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( xa_mh.x_p2, d_hrr )).y );

// Calculate the string representation of the tip of the component vector that represents VMG.

  s_vr_x = (String)(int16_t)( PIXELS_PER_KNOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( p_var_display_data->xd_vh, d_hrr )).x );
  s_vr_y = (String)(int16_t)( -PIXELS_PER_KNOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( p_var_display_data->xd_vh, d_hrr )).y );

// Calculate the string representations of the component vectors that represent the post and tip of the rudder.

  xd_rp = ww_vector::x_component_from_radial( ww_vector::x_rotate( p_var_display_data->xd_ph, d_hrr ));

  s_rp_x = (String)(int16_t)( PIXELS_PER_FOOT * xd_rp.x );
  s_rp_y = (String)(int16_t)( -PIXELS_PER_FOOT * xd_rp.y );

  xd_rt = ww_vector::x_add_component( xd_rp, ww_vector::x_component_from_radial( ww_vector::x_rotate( p_var_display_data->xd_rh, d_hrr )));

  s_rt_x = (String)(int16_t)( PIXELS_PER_FOOT * xd_rt.x );
  s_rt_y = (String)(int16_t)( -PIXELS_PER_FOOT * xd_rt.y );

// Calculate the string representation of the tip of the component vector that represents apparent wind.

  s_ar_x =  (String)(int16_t)( PIXELS_PER_KNOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( p_var_display_data->xd_ah, d_hrr )).x );
  s_ar_y =  (String)(int16_t)( -PIXELS_PER_KNOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( p_var_display_data->xd_ah, d_hrr )).y );

// Calculate the string representation of the tip of the component vector that represents true wind.

  s_tr_x =  (String)(int16_t)( PIXELS_PER_KNOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( p_var_display_data->xd_th, d_hrr )).x );
  s_tr_y =  (String)(int16_t)( -PIXELS_PER_KNOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( p_var_display_data->xd_th, d_hrr )).y );

// Calculate the string representation of the tip of the component vector that represents course and speed.

  s_cr_x =  (String)(int16_t)( PIXELS_PER_KNOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( p_var_display_data->xd_ch, d_hrr )).x );
  s_cr_y =  (String)(int16_t)( -PIXELS_PER_KNOT * ww_vector::x_component_from_radial( ww_vector::x_rotate( p_var_display_data->xd_ch, d_hrr )).y );

// calculate the string representation of the shadow vectors.

  s_cr_shadow_begin_x = s_tr_x;
  s_cr_shadow_begin_y = s_tr_y;
  s_cr_shadow_end_x = s_ar_x;
  s_cr_shadow_end_y = s_ar_y;
  s_tr_shadow_begin_x = s_cr_x;
  s_tr_shadow_begin_y = s_cr_y;
  s_tr_shadow_end_x = s_ar_x;
  s_tr_shadow_end_y = s_ar_y;
  s_vr_shadow_begin_x = s_cr_x;
  s_vr_shadow_begin_y = s_cr_y;
  s_vr_shadow_end_x = s_vr_x;
  s_vr_shadow_end_y = s_vr_y;

// Calculate the string representation of the x coordinate of the ball that represents VMG, leeway and true wind relative to true north,
// relative to centre of the panel.

  if( p_var_display_data->d_ch > CH_BAND / 2.0 ) p_var_display_data->d_ch = CH_BAND / 2.0;
  else if( p_var_display_data->d_ch < -CH_BAND / 2.0 ) p_var_display_data->d_ch = -CH_BAND / 2.0;

  if( p_var_display_data->d_vt > VT_BAND / 2.0 ) p_var_display_data->d_vt = VT_BAND / 2.0;
  else if( p_var_display_data->d_vt < -VT_BAND / 2.0 ) p_var_display_data->d_vt = -VT_BAND / 2.0;

  if( p_var_display_data->d_tn > TN_BAND / 2.0 ) p_var_display_data->d_tn = TN_BAND / 2.0;
  else if( p_var_display_data->d_tn < -TN_BAND / 2.0 ) p_var_display_data->d_tn = -TN_BAND / 2.0;

  s_vmg = (String)(int16_t)(( (double)PANEL_WIDTH / VT_BAND ) * p_var_display_data->d_vt );
  s_crh = (String)(int16_t)(( (double)PANEL_WIDTH / CH_BAND ) * p_var_display_data->d_ch );
  s_trn = (String)(int16_t)(( (double)PANEL_WIDTH / TN_BAND ) * p_var_display_data->d_tn );

// Calculate the string representation of the apparent wind angle.

  s_arh = (String)(int16_t)( PIXELS_PER_DEGREE * ww_vector::d_angle_from_radial( p_var_display_data->xd_ah ));

// Calculate the string representation of the points of the hull shape.

  for( int8_t s8_index = 0; s8_index <= HULL_POINTS_BOUND; s8_index++ ) {
    as_hx[ s8_index ] = (String)(int16_t)( PIXELS_PER_FOOT * ( ww_vector::x_component_from_radial( ww_vector::x_rotate( p_var_display_data->axd_hh[ s8_index ], d_hrr )).x ));
    as_hy[ s8_index ] = (String)(int16_t)( -PIXELS_PER_FOOT * ( ww_vector::x_component_from_radial( ww_vector::x_rotate( p_var_display_data->axd_hh[ s8_index ], d_hrr )).y ));
  }

  s_0 = as_hx[ 0 ];
  s_1 = as_hy[ 0 ];
  s_2 = as_hx[ 1 ];
  s_3 = as_hy[ 1 ];
  s_4 = as_hx[ 2 ];
  s_5 = as_hy[ 2 ];
  s_6 = as_hx[ 3 ];
  s_7 = as_hy[ 3 ];
  s_8 = as_hx[ 4 ];
  s_9 = as_hy[ 4 ];
  s_10 = as_hx[ 5 ];
  s_11 = as_hy[ 5 ];
  s_12 = as_hx[ 6 ];
  s_13 = as_hy[ 6 ];
  s_14 = as_hx[ 7 ];
  s_15 = as_hy[ 7 ];
  s_16 = as_hx[ 8 ];
  s_17 = as_hy[ 8 ];
  s_18 = as_hx[ 9 ];
  s_19 = as_hy[ 9 ];
  s_20 = as_hx[ 10 ];
  s_21 = as_hy[ 10 ];
  s_22 = as_hx[ 11 ];
  s_23 = as_hy[ 11 ];
  s_24 = as_hx[ 12 ];
  s_25 = as_hy[ 12 ];

  s8_heart_beat = p_var_display_data->s8_hb;

  // s_crh = (String)p_var_display_data->d_ch;

  if( p_var_display_data->b_up ) {
    s_vmg_clr = VMG_UPWIND_COLOUR;
    s_vmg_s_clr = VMG_UPWIND_SHADOW_COLOUR;
    s_vmg_b_clr = VMG_BALL_UPWIND_COLOUR;
  }
  else {
    s_vmg_clr = VMG_DOWNWIND_COLOUR;
    s_vmg_s_clr = VMG_DOWNWIND_SHADOW_COLOUR;
    s_vmg_b_clr = VMG_BALL_DOWNWIND_COLOUR;
  }

  strcpy( pac_utc, p_var_display_data->ac_utc ); // time display

  if( s8_heart_beat == 1 ) s_hbt_clr = HEART_BEAT_COLOUR_ON; else s_hbt_clr = HEART_BEAT_COLOUR_OFF;

//
// The remaining code was generated by ArduinoJson.
//

  JsonDocument var_01;

  var_01["key"] = "variables";

  JsonArray hl = var_01["hl"].to<JsonArray>();
  hl.add(s_0);
  hl.add(s_1);
  hl.add(s_2);
  hl.add(s_3);
  hl.add(s_4);
  hl.add(s_5);
  hl.add(s_6);
  hl.add(s_7);
  hl.add(s_8);
  hl.add(s_9);
  hl.add(s_10);
  hl.add(s_11);
  hl.add(s_12);
  hl.add(s_13);
  hl.add(s_14);
  hl.add(s_15);
  hl.add(s_16);
  hl.add(s_17);
  hl.add(s_18);
  hl.add(s_19);
  hl.add(s_20);
  hl.add(s_21);
  hl.add(s_22);
  hl.add(s_23);
  hl.add(s_24);
  hl.add(s_25);

  JsonObject bt = var_01["bt"].to<JsonObject>();
  bt["x"] = s_cr_x;
  bt["y"] = s_cr_y;

  JsonObject rdr = var_01["rdr"].to<JsonObject>();

  JsonObject rdr_post = rdr["post"].to<JsonObject>();
  rdr_post["x"] = s_rp_x;
  rdr_post["y"] = s_rp_y;

  JsonObject rdr_tip = rdr["tip"].to<JsonObject>();
  rdr_tip["x"] = s_rt_x;
  rdr_tip["y"] = s_rt_y;

  JsonObject tw = var_01["tw"].to<JsonObject>();
  tw["x"] = s_tr_x;
  tw["y"] = s_tr_y;

  JsonObject aw = var_01["aw"].to<JsonObject>();
  aw["x"] = s_ar_x;
  aw["y"] = s_ar_y;

  JsonObject vmg = var_01["vmg"].to<JsonObject>();
  vmg["clr"] = s_vmg_clr;
  vmg["x"] = s_vr_x;
  vmg["y"] = s_vr_y;

  JsonObject bt_s = var_01["bt_s"].to<JsonObject>();

  JsonObject bt_s_begin = bt_s["begin"].to<JsonObject>();
  bt_s_begin["x"] = s_cr_shadow_begin_x;
  bt_s_begin["y"] = s_cr_shadow_begin_y;

  JsonObject bt_s_end = bt_s["end"].to<JsonObject>();
  bt_s_end["x"] = s_cr_shadow_end_x;
  bt_s_end["y"] = s_cr_shadow_end_y;

  JsonObject tw_s = var_01["tw_s"].to<JsonObject>();

  JsonObject tw_s_begin = tw_s["begin"].to<JsonObject>();
  tw_s_begin["x"] = s_tr_shadow_begin_x;
  tw_s_begin["y"] = s_tr_shadow_begin_y;

  JsonObject tw_s_end = tw_s["end"].to<JsonObject>();
  tw_s_end["x"] = s_tr_shadow_end_x;
  tw_s_end["y"] = s_tr_shadow_end_y;

  JsonObject vmg_s = var_01["vmg_s"].to<JsonObject>();
  vmg_s["clr"] = s_vmg_s_clr;

  JsonObject vmg_s_begin = vmg_s["begin"].to<JsonObject>();
  vmg_s_begin["x"] = s_vr_shadow_begin_x;
  vmg_s_begin["y"] = s_vr_shadow_begin_y;

  JsonObject vmg_s_end = vmg_s["end"].to<JsonObject>();
  vmg_s_end["x"] = s_vr_shadow_end_x;
  vmg_s_end["y"] = s_vr_shadow_end_y;

  JsonObject vmg_ball = var_01["vmg_ball"].to<JsonObject>();
  vmg_ball["clr"] = s_vmg_b_clr;
  vmg_ball["x"] = s_vmg;
  var_01["crh_ball"] = s_crh;
  var_01["trn_ball"] = s_trn;

  JsonArray tru_nth_point = var_01["tru_nth"]["point"].to<JsonArray>();

  JsonObject tru_nth_point_0 = tru_nth_point.add<JsonObject>();
  tru_nth_point_0["x"] = s_nr_0_x;
  tru_nth_point_0["y"] = s_nr_0_y;

  JsonObject tru_nth_point_1 = tru_nth_point.add<JsonObject>();
  tru_nth_point_1["x"] = s_nr_1_x;
  tru_nth_point_1["y"] = s_nr_1_y;

  JsonObject tru_nth_point_2 = tru_nth_point.add<JsonObject>();
  tru_nth_point_2["x"] = s_nr_2_x;
  tru_nth_point_2["y"] = s_nr_2_y;

  JsonArray mag_nth_point = var_01["mag_nth"]["point"].to<JsonArray>();

  JsonObject mag_nth_point_0 = mag_nth_point.add<JsonObject>();
  mag_nth_point_0["x"] = s_mr_0_x;
  mag_nth_point_0["y"] = s_mr_0_y;

  JsonObject mag_nth_point_1 = mag_nth_point.add<JsonObject>();
  mag_nth_point_1["x"] = s_mr_1_x;
  mag_nth_point_1["y"] = s_mr_1_y;

  JsonObject mag_nth_point_2 = mag_nth_point.add<JsonObject>();
  mag_nth_point_2["x"] = s_mr_2_x;
  mag_nth_point_2["y"] = s_mr_2_y;
  var_01["hbt_clr"] = s_hbt_clr;
  var_01["utc"] = ac_utc;

  var_01.shrinkToFit();  // optional

  serializeJson(var_01, pac_json_var_01, 4096);

  delay(100);

}



void ww_json::v_json_var_02( char* pac_json_var_02 ) {

//
// Load the variable display data for page 03 into a JSON array.
//

char ac_vmg[ 4 ];

  sprintf( ac_vmg, "%+4.1f", p_var_display_data->d_vt );

  JsonDocument var_02;

  var_02["key"] = "variables";
  var_02["vmg"] = ac_vmg;

  serializeJson(var_02, pac_json_var_02, 128);
  delay(100);

}



void ww_json::v_json_var_03( char* pac_json_var_03 ) {

//
// s_arh is the string representation of d_arh, which is the canvas_2 'x' coordinate 
// of the centre of the indicator bar (pixels).
// 
// s_offset is the offset string, calculated from correction_data->d_orh.  It doesn't need filtering.
//
// s_crh is the string representation of d_ch, which is the canvas_4 'x' coordinate
// of the centre of the indicator bar (pixels).
//
// s_variation is the variation string, calculated from correction_data->d_mrn.
//
// s_fc is the filter cut-off frequency string, calculated from correction_data->d_fc.
//

  String s_offset = String( p_correction_data->s16_orh );
  String s_variation = String( p_correction_data->s16_mrn );
  String s_fc = String( ww_filter::d_fc_from_index( p_correction_data->s16_fc ));

  double d_arh = ww_vector::d_angle_from_radial( p_var_display_data->xd_ah );
  double d_ch = p_var_display_data->d_ch;

  if( d_arh > AH_BAND / 2.0 ) d_arh = AH_BAND / 2.0;
  else if( d_arh < -AH_BAND / 2.0 ) d_arh = -AH_BAND / 2.0;

  if( d_ch > CH_BAND / 2.0 ) d_ch = CH_BAND / 2.0;
  else if( d_ch < -CH_BAND / 2.0 ) d_ch = -CH_BAND / 2.0;

  String s_arh = (String)(int16_t)(( (double)P2_PANEL_WIDTH / ( 2 * AH_BAND )) * d_arh );
  String s_crh = (String)(int16_t)(( (double)P2_PANEL_WIDTH / ( 2 * CH_BAND )) * d_ch );

//
// The remaining code was generated by ArduinoJson.
//

  JsonDocument var_03;

  var_03["key"] = "variables";

  JsonObject corrections = var_03["corrections"].to<JsonObject>();
  corrections["arh"] = s_arh;
  corrections["crh"] = s_crh;
  var_03["offset"] = s_offset;
  var_03["variation"] = s_variation;
  var_03["fc"] = s_fc;

  serializeJson(var_03, pac_json_var_03, 256);

  delay( 100 );

}



void ww_json::v_json_var_04( char* pac_json_var_04 ) {

//
// Load the variable display data for page 04 into a JSON array.
//

char ac_dev[ 7 ];
char ac_crn[ 7 ];

  sprintf( ac_dev, "%+3.1f", p_var_display_data->d_cd );
  sprintf( ac_crn, "%+3.1f", p_var_display_data->d_cn );

  JsonDocument var_04;

  var_04["key"] = "variables";
  var_04["dev"] = ac_dev;
  var_04["crn"] = ac_crn;

  serializeJson(var_04, pac_json_var_04, 256);

  delay(100);

}



arrowhead_t ww_json::x_arrow_head_from_radial( radial_vector_t x_radial_vector ) {

arrowhead_t x_arrowhead;

  x_arrowhead.x_p0.l = x_radial_vector.l;
  x_arrowhead.x_p1.l = ( 1.0 - ARROWHEAD_LENGTH ) * x_radial_vector.l;
  x_arrowhead.x_p2.l = ( 1.0 - ARROWHEAD_LENGTH ) * x_radial_vector.l;

  x_arrowhead.x_p0.a = x_radial_vector.a;
  x_arrowhead.x_p1.a = ww_vector::d_add_angle( x_radial_vector.a, DEGREES_FROM_RADIANS * atan( ARROWHEAD_WIDTH / 2.0 ));
  x_arrowhead.x_p2.a = ww_vector::d_add_angle( x_radial_vector.a, -DEGREES_FROM_RADIANS * atan( ARROWHEAD_WIDTH / 2.0 ));

  return x_arrowhead;

}
